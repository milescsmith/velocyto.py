from pathlib import Path
from typing import Optional, Annotated

import pysam
import typer
from loguru import logger

app = typer.Typer(
    name="velocount-run",
    help="Correct barcodes for DropEst data",
    rich_markup_mode="markdown",
    no_args_is_help=True,
)


@app.callback(invoke_without_command=True)
@app.command(name="dropest_bc_correct")
def dropest_bc_correct(
    bamfilepath: Annotated[
        Path, typer.Argument(exists=True, file_okay=True, dir_okay=False, readable=True, resolve_path=True)
    ],
    dropest_out: Annotated[
        Path, typer.Argument(exists=True, file_okay=True, dir_okay=False, readable=True, resolve_path=True)
    ],
    corrected_output: Annotated[
        Optional[Path],
        typer.Option(
            "-o",
            "--corrected-output",
            help="The file output of the output bam file. Otherwise the file will be outputted in the same folder of the input with the prefix `correct_`",
        ),
    ] = None,
) -> None:
    """Using the output of DropEst:
    (1) Corrects barcodes directly in the bam file
    (2) Produces a valid barcodes list

    BAMFILEPATH - bam file with sorted reads obtained running DropEst

    DROPEST-OUT - R dump `rds` file generated by DropEst
    """

    try:
        import rpy2.robjects as ro

        from ..r_interface import convert_r_obj
    except Exception:
        msg = "A problem was encountered importing rpy2. To run this `velocount tools` rpy2 and R need to be installed (the use conda is recommended)"
        ImportError(msg)

    parentpath = bamfilepath.parent
    bamfilename = bamfilepath.name
    filename = dropest_out
    logger.info(f"Loading `merge_targets` from {filename} using R / rpy2")
    mapping = convert_r_obj(ro.r(f"rds <- readRDS('{filename}'); rds$merge_targets"))  # a dict

    output_path = parentpath.joinpath(f"barcodes_{bamfilename.split('_')[0]}.tsv")
    logger.info(f"Generating {output_path}")
    with open(output_path, "w") as fout:
        unique_bcs = set(mapping.values())
        str_ = "\n".join(list(unique_bcs))
        fout.write(str_)

    if corrected_output is None:
        bam_out_path = parentpath.joinpath(f"correct_{bamfilename}")
    else:
        bam_out_path = corrected_output

    with pysam.AlignmentFile(bamfilepath, mode="rb") as infile, pysam.AlignmentFile(
        str(bam_out_path), mode="wb", template=infile
    ) as outfile:
        for read in infile:
            # read: pysam.AlignedRead
            cb = read.get_tag("CB")
            if cb in mapping:
                read.set_tag("CB", mapping[cb], value_type="Z")
            outfile.write(read)
    logger.info("Done")

    return
